import tkinter as tk
from tkinter import messagebox
import json
import os
import tkinter as tk
from tkinter import messagebox
import json
import os
import tkinter as tk
from tkinter import messagebox, filedialog
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
import json
import os

PROFILES_FILE = "profiles.json"
profiles = []

# Load images as text placeholders
CHECKMARK = "✔"
XMARK = "✘"

# Function to save data to JSON
def save_to_json(data, filename):
    try:
        with open(filename, 'w') as file:
            json.dump(data, file, indent=4)
    except IOError:
        messagebox.showerror("Error", "Could not save data to file.")

# Function to load data from JSON
def load_from_json(filename):
    if os.path.exists(filename):
        try:
            with open(filename, 'r') as file:
                data = json.load(file)
                if isinstance(data, list):
                    return [p for p in data if isinstance(p, dict)]
        except IOError:
            messagebox.showerror("Error", "Could not load data from file.")
    return []

# Load profiles from JSON on startup
profiles = load_from_json(PROFILES_FILE)

# Function to update status labels
def update_status_label(label, is_complete):
    status_text = f"{CHECKMARK if is_complete else XMARK} {'Complete' if is_complete else 'Incomplete'}"
    label.config(text=status_text, fg="green" if is_complete else "red")

def open_credit_window(profile_name):
    profile = next((p for p in profiles if p['name'] == profile_name), None)
    if not profile:
        messagebox.showwarning("Profile Not Found", f"Profile '{profile_name}' not found.")
        return

    credit_window = tk.Toplevel()
    credit_window.title(f"credit for Profile: {profile_name}")

    # Set credit_window to be on top of the root window
    credit_window.transient(root)
    credit_window.grab_set()  # Disable interaction with the main window
    credit_window.focus()  # Focus on the credit window

    credit_list = tk.Listbox(credit_window, width=50, height=20)
    credit_list.pack(side=tk.LEFT, fill=tk.Y)

    scrollbar = tk.Scrollbar(credit_window)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    credit_list.configure(yscrollcommand=scrollbar.set)
    scrollbar.configure(command=credit_list.yview)

    def print_credit():
        credit_list.delete(0, tk.END)
        for credit in profile.get('credit', []):
            credit_info = f"Name: {credit['name']}, Email: {credit.get('email', '')}, Phone: {credit.get('phone', '')}"
            credit_list.insert(tk.END, credit_info)

    def add_credit():
        def create_add_credit_window():
            add_credit_window = tk.Toplevel()
            add_credit_window.title("Add credit")
            add_credit_window.transient(credit_window)  # Make sure this window stays in front of the credit window
            add_credit_window.grab_set()  # Ensure the new window is active
            add_credit_window.focus()  # Focus on the add credit window

            tk.Label(add_credit_window, text="Name:").pack(pady=10)
            name_entry = tk.Entry(add_credit_window)
            name_entry.pack()

            tk.Label(add_credit_window, text="Email Address:").pack(pady=10)
            email_entry = tk.Entry(add_credit_window)
            email_entry.pack()

            tk.Label(add_credit_window, text="Phone Number:").pack(pady=10)
            phone_entry = tk.Entry(add_credit_window)
            phone_entry.pack()

            def save_credit():
                if 'credit' not in profile:
                    profile['credit'] = []
                new_credit = {
                    'name': name_entry.get(),
                    'phone': phone_entry.get(),
                    'email': email_entry.get()
                }
                profile['credit'].append(new_credit)
                save_to_json(profiles, PROFILES_FILE)
                print_credit()
                update_credit_label(profile)

                add_another = messagebox.askyesno("Add Another", "Would you like to add another credit?")
                if add_another:
                    name_entry.delete(0, tk.END)
                    phone_entry.delete(0, tk.END)
                    email_entry.delete(0, tk.END)
                    name_entry.focus_set()  # Refocus on the name entry for the next credit
                else:
                    add_credit_window.destroy()
                    credit_window.focus_set()  # Return focus to the credit window

            tk.Button(add_credit_window, text="Save credit", command=save_credit).pack(pady=10)

            name_entry.focus_set()  # Set focus to the name entry field

        create_add_credit_window()

    def edit_credit():
        selected_index = credit_list.curselection()
        if not selected_index:
            messagebox.showwarning("Selection Error", "No credit selected.")
            return

        selected_index = selected_index[0]
        selected_credit = profile['credit'][selected_index]

        def create_edit_credit_window():
            edit_credit_window = tk.Toplevel()
            edit_credit_window.title("Edit credit")
            edit_credit_window.transient(credit_window)  # Keep window in front
            edit_credit_window.grab_set()  # Make this window modal
            edit_credit_window.focus()  # Focus on the edit window

            tk.Label(edit_credit_window, text="Name:").pack(pady=10)
            name_entry = tk.Entry(edit_credit_window)
            name_entry.insert(0, selected_credit['name'])
            name_entry.pack()

            tk.Label(edit_credit_window, text="Email Address:").pack(pady=10)
            email_entry = tk.Entry(edit_credit_window)
            email_entry.insert(0, selected_credit.get('email', ''))
            email_entry.pack()

            tk.Label(edit_credit_window, text="Phone Number:").pack(pady=10)
            phone_entry = tk.Entry(edit_credit_window)
            phone_entry.insert(0, selected_credit.get('phone', ''))
            phone_entry.pack()

            def save_edits():
                profile['credit'][selected_index] = {
                    'name': name_entry.get(),
                    'email': email_entry.get(),
                    'phone': phone_entry.get()
                }
                save_to_json(profiles, PROFILES_FILE)
                messagebox.showinfo("Success", "credit updated successfully!")
                print_credit()  # Refresh the credit listbox
                edit_credit_window.destroy()

            tk.Button(edit_credit_window, text="Save Changes", command=save_edits).pack(pady=20)

        create_edit_credit_window()

    import tkinter.filedialog as filedialog

    def generate_pdf():
        # Open a file dialog to ask the user where to save the PDF
        pdf_filename = filedialog.asksaveasfilename(
            defaultextension=".pdf", 
            filetypes=[("PDF files", "*.pdf")],
            title="Save PDF As"
        )
        
        if not pdf_filename:  # If the user cancels, exit the function
            return
        
        c = canvas.Canvas(pdf_filename, pagesize=letter)
        width, height = letter

        c.drawString(100, height - 50, f"credit for Profile: {profile_name}")
        y_position = height - 100

        for credit in profile.get('credit', []):
            credit_info = f"Name: {credit['name']}, Email: {credit.get('email', '')}, Phone: {credit.get('phone', '')}"
            c.drawString(100, y_position, credit_info)
            y_position -= 20
            if y_position < 50:  # Create a new page if space runs out
                c.showPage()
                y_position = height - 50

        c.save()
        messagebox.showinfo("Success", f"PDF saved as {pdf_filename}")

    # Adding this to the credit window
    tk.Button(credit_window, text="Generate PDF", command=generate_pdf).pack(pady=5)


    tk.Button(credit_window, text="Add credit", command=add_credit).pack(pady=5)
    tk.Button(credit_window, text="Edit credit", command=edit_credit).pack(pady=5)

    print_credit()

    # Ensure the credit window stays in front of the profile manager window
    credit_window.protocol("WM_DELETE_WINDOW", lambda: (credit_window.grab_release(), credit_window.destroy()))



def open_banking_window(profile_name):
    profile = next((p for p in profiles if p['name'] == profile_name), None)
    if not profile:
        messagebox.showwarning("Profile Not Found", f"Profile '{profile_name}' not found.")
        return

    banking_window = tk.Toplevel()
    banking_window.title(f"banking for Profile: {profile_name}")

    # Set banking_window to be on top of the root window
    banking_window.transient(root)
    banking_window.grab_set()  # Disable interaction with the main window
    banking_window.focus()  # Focus on the banking window

    banking_list = tk.Listbox(banking_window, width=50, height=20)
    banking_list.pack(side=tk.LEFT, fill=tk.Y)

    scrollbar = tk.Scrollbar(banking_window)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    banking_list.configure(yscrollcommand=scrollbar.set)
    scrollbar.configure(command=banking_list.yview)

    def print_banking():
        banking_list.delete(0, tk.END)
        for Bank in profile.get('banking', []):
            Bank_info = f"Name: {Bank['name']}, Email: {Bank.get('email', '')}, Phone: {Bank.get('phone', '')}"
            banking_list.insert(tk.END, Bank_info)

    def add_Bank():
        def create_add_Bank_window():
            add_Bank_window = tk.Toplevel()
            add_Bank_window.title("Add Bank")
            add_Bank_window.transient(banking_window)  # Make sure this window stays in front of the banking window
            add_Bank_window.grab_set()  # Ensure the new window is active
            add_Bank_window.focus()  # Focus on the add Bank window

            tk.Label(add_Bank_window, text="Name:").pack(pady=10)
            name_entry = tk.Entry(add_Bank_window)
            name_entry.pack()

            tk.Label(add_Bank_window, text="Email Address:").pack(pady=10)
            email_entry = tk.Entry(add_Bank_window)
            email_entry.pack()

            tk.Label(add_Bank_window, text="Phone Number:").pack(pady=10)
            phone_entry = tk.Entry(add_Bank_window)
            phone_entry.pack()

            def save_Bank():
                if 'banking' not in profile:
                    profile['banking'] = []
                new_Bank = {
                    'name': name_entry.get(),
                    'phone': phone_entry.get(),
                    'email': email_entry.get()
                }
                profile['banking'].append(new_Bank)
                save_to_json(profiles, PROFILES_FILE)
                print_banking()
                update_banking_label(profile)

                add_another = messagebox.askyesno("Add Another", "Would you like to add another Bank?")
                if add_another:
                    name_entry.delete(0, tk.END)
                    phone_entry.delete(0, tk.END)
                    email_entry.delete(0, tk.END)
                    name_entry.focus_set()  # Refocus on the name entry for the next Bank
                else:
                    add_Bank_window.destroy()
                    banking_window.focus_set()  # Return focus to the banking window

            tk.Button(add_Bank_window, text="Save Bank", command=save_Bank).pack(pady=10)

            name_entry.focus_set()  # Set focus to the name entry field

        create_add_Bank_window()

    def edit_Bank():
        selected_index = banking_list.curselection()
        if not selected_index:
            messagebox.showwarning("Selection Error", "No Bank selected.")
            return

        selected_index = selected_index[0]
        selected_Bank = profile['banking'][selected_index]

        def create_edit_Bank_window():
            edit_Bank_window = tk.Toplevel()
            edit_Bank_window.title("Edit Bank")
            edit_Bank_window.transient(banking_window)  # Keep window in front
            edit_Bank_window.grab_set()  # Make this window modal
            edit_Bank_window.focus()  # Focus on the edit window

            tk.Label(edit_Bank_window, text="Name:").pack(pady=10)
            name_entry = tk.Entry(edit_Bank_window)
            name_entry.insert(0, selected_Bank['name'])
            name_entry.pack()

            tk.Label(edit_Bank_window, text="Email Address:").pack(pady=10)
            email_entry = tk.Entry(edit_Bank_window)
            email_entry.insert(0, selected_Bank.get('email', ''))
            email_entry.pack()

            tk.Label(edit_Bank_window, text="Phone Number:").pack(pady=10)
            phone_entry = tk.Entry(edit_Bank_window)
            phone_entry.insert(0, selected_Bank.get('phone', ''))
            phone_entry.pack()

            def save_edits():
                profile['banking'][selected_index] = {
                    'name': name_entry.get(),
                    'email': email_entry.get(),
                    'phone': phone_entry.get()
                }
                save_to_json(profiles, PROFILES_FILE)
                messagebox.showinfo("Success", "Bank updated successfully!")
                print_banking()  # Refresh the banking listbox
                edit_Bank_window.destroy()

            tk.Button(edit_Bank_window, text="Save Changes", command=save_edits).pack(pady=20)

        create_edit_Bank_window()

    import tkinter.filedialog as filedialog

    def generate_pdf():
        # Open a file dialog to ask the user where to save the PDF
        pdf_filename = filedialog.asksaveasfilename(
            defaultextension=".pdf", 
            filetypes=[("PDF files", "*.pdf")],
            title="Save PDF As"
        )
        
        if not pdf_filename:  # If the user cancels, exit the function
            return
        
        c = canvas.Canvas(pdf_filename, pagesize=letter)
        width, height = letter

        c.drawString(100, height - 50, f"banking for Profile: {profile_name}")
        y_position = height - 100

        for Bank in profile.get('banking', []):
            Bank_info = f"Name: {Bank['name']}, Email: {Bank.get('email', '')}, Phone: {Bank.get('phone', '')}"
            c.drawString(100, y_position, Bank_info)
            y_position -= 20
            if y_position < 50:  # Create a new page if space runs out
                c.showPage()
                y_position = height - 50

        c.save()
        messagebox.showinfo("Success", f"PDF saved as {pdf_filename}")

    # Adding this to the banking window
    tk.Button(banking_window, text="Generate PDF", command=generate_pdf).pack(pady=5)


    tk.Button(banking_window, text="Add Bank", command=add_Bank).pack(pady=5)
    tk.Button(banking_window, text="Edit Bank", command=edit_Bank).pack(pady=5)

    print_banking()

    # Ensure the banking window stays in front of the profile manager window
    banking_window.protocol("WM_DELETE_WINDOW", lambda: (banking_window.grab_release(), banking_window.destroy()))


def open_contacts_window(profile_name):
    profile = next((p for p in profiles if p['name'] == profile_name), None)
    if not profile:
        messagebox.showwarning("Profile Not Found", f"Profile '{profile_name}' not found.")
        return

    contacts_window = tk.Toplevel()
    contacts_window.title(f"Contacts for Profile: {profile_name}")

    # Set contacts_window to be on top of the root window
    contacts_window.transient(root)
    contacts_window.grab_set()  # Disable interaction with the main window
    contacts_window.focus()  # Focus on the contacts window

    contacts_list = tk.Listbox(contacts_window, width=50, height=20)
    contacts_list.pack(side=tk.LEFT, fill=tk.Y)

    scrollbar = tk.Scrollbar(contacts_window)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    contacts_list.configure(yscrollcommand=scrollbar.set)
    scrollbar.configure(command=contacts_list.yview)

    def print_contacts():
        contacts_list.delete(0, tk.END)
        for contact in profile.get('contacts', []):
            contact_info = f"Name: {contact['name']}, Email: {contact.get('email', '')}, Phone: {contact.get('phone', '')}"
            contacts_list.insert(tk.END, contact_info)

    def add_contact():
        def create_add_contact_window():
            add_contact_window = tk.Toplevel()
            add_contact_window.title("Add Contact")
            add_contact_window.transient(contacts_window)  # Make sure this window stays in front of the contacts window
            add_contact_window.grab_set()  # Ensure the new window is active
            add_contact_window.focus()  # Focus on the add contact window

            tk.Label(add_contact_window, text="Name:").pack(pady=10)
            name_entry = tk.Entry(add_contact_window)
            name_entry.pack()

            tk.Label(add_contact_window, text="Email Address:").pack(pady=10)
            email_entry = tk.Entry(add_contact_window)
            email_entry.pack()

            tk.Label(add_contact_window, text="Phone Number:").pack(pady=10)
            phone_entry = tk.Entry(add_contact_window)
            phone_entry.pack()

            def save_contact():
                if 'contacts' not in profile:
                    profile['contacts'] = []
                new_contact = {
                    'name': name_entry.get(),
                    'phone': phone_entry.get(),
                    'email': email_entry.get()
                }
                profile['contacts'].append(new_contact)
                save_to_json(profiles, PROFILES_FILE)
                print_contacts()
                update_contacts_label(profile)

                add_another = messagebox.askyesno("Add Another", "Would you like to add another contact?")
                if add_another:
                    name_entry.delete(0, tk.END)
                    phone_entry.delete(0, tk.END)
                    email_entry.delete(0, tk.END)
                    name_entry.focus_set()  # Refocus on the name entry for the next contact
                else:
                    add_contact_window.destroy()
                    contacts_window.focus_set()  # Return focus to the contacts window

            tk.Button(add_contact_window, text="Save Contact", command=save_contact).pack(pady=10)

            name_entry.focus_set()  # Set focus to the name entry field

        create_add_contact_window()

    def edit_contact():
        selected_index = contacts_list.curselection()
        if not selected_index:
            messagebox.showwarning("Selection Error", "No contact selected.")
            return

        selected_index = selected_index[0]
        selected_contact = profile['contacts'][selected_index]

        def create_edit_contact_window():
            edit_contact_window = tk.Toplevel()
            edit_contact_window.title("Edit Contact")
            edit_contact_window.transient(contacts_window)  # Keep window in front
            edit_contact_window.grab_set()  # Make this window modal
            edit_contact_window.focus()  # Focus on the edit window

            tk.Label(edit_contact_window, text="Name:").pack(pady=10)
            name_entry = tk.Entry(edit_contact_window)
            name_entry.insert(0, selected_contact['name'])
            name_entry.pack()

            tk.Label(edit_contact_window, text="Email Address:").pack(pady=10)
            email_entry = tk.Entry(edit_contact_window)
            email_entry.insert(0, selected_contact.get('email', ''))
            email_entry.pack()

            tk.Label(edit_contact_window, text="Phone Number:").pack(pady=10)
            phone_entry = tk.Entry(edit_contact_window)
            phone_entry.insert(0, selected_contact.get('phone', ''))
            phone_entry.pack()

            def save_edits():
                profile['contacts'][selected_index] = {
                    'name': name_entry.get(),
                    'email': email_entry.get(),
                    'phone': phone_entry.get()
                }
                save_to_json(profiles, PROFILES_FILE)
                messagebox.showinfo("Success", "Contact updated successfully!")
                print_contacts()  # Refresh the contacts listbox
                edit_contact_window.destroy()

            tk.Button(edit_contact_window, text="Save Changes", command=save_edits).pack(pady=20)

        create_edit_contact_window()

    import tkinter.filedialog as filedialog

    def generate_pdf():
        # Open a file dialog to ask the user where to save the PDF
        pdf_filename = filedialog.asksaveasfilename(
            defaultextension=".pdf", 
            filetypes=[("PDF files", "*.pdf")],
            title="Save PDF As"
        )
        
        if not pdf_filename:  # If the user cancels, exit the function
            return
        
        c = canvas.Canvas(pdf_filename, pagesize=letter)
        width, height = letter

        c.drawString(100, height - 50, f"Contacts for Profile: {profile_name}")
        y_position = height - 100

        for contact in profile.get('contacts', []):
            contact_info = f"Name: {contact['name']}, Email: {contact.get('email', '')}, Phone: {contact.get('phone', '')}"
            c.drawString(100, y_position, contact_info)
            y_position -= 20
            if y_position < 50:  # Create a new page if space runs out
                c.showPage()
                y_position = height - 50

        c.save()
        messagebox.showinfo("Success", f"PDF saved as {pdf_filename}")

    # Adding this to the contacts window
    tk.Button(contacts_window, text="Generate PDF", command=generate_pdf).pack(pady=5)


    tk.Button(contacts_window, text="Add Contact", command=add_contact).pack(pady=5)
    tk.Button(contacts_window, text="Edit Contact", command=edit_contact).pack(pady=5)

    print_contacts()

    # Ensure the contacts window stays in front of the profile manager window
    contacts_window.protocol("WM_DELETE_WINDOW", lambda: (contacts_window.grab_release(), contacts_window.destroy()))


def create_profile_window():
    create_window = tk.Toplevel()
    create_window.title("Create New Profile")

    tk.Label(create_window, text="Profile Name:").pack(pady=10)
    name_entry = tk.Entry(create_window)
    name_entry.pack()

    def save_profile():
        profile_name = name_entry.get()
        if not profile_name:
            messagebox.showwarning("Input Error", "Profile name cannot be empty.")
            return

        if any(p['name'] == profile_name for p in profiles):
            messagebox.showwarning("Profile Exists", f"Profile '{profile_name}' already exists.")
            return

        new_profile = {
            'name': profile_name,
            'vehicles': [],
            'contacts': [],
            'documents': [],
            'housings': None,  # Make housing initially None
            'housing2': None,  # Make housing2 initially None
            'banking': [],
            'credit': []
        }
        profiles.append(new_profile)
        save_to_json(profiles, PROFILES_FILE)
        profiles_listbox.insert(tk.END, profile_name)
        create_window.destroy()

    tk.Button(create_window, text="Save Profile", command=save_profile).pack(pady=10)

def open_housings_window(profile_name):
    profile = next((p for p in profiles if p['name'] == profile_name), None)
    if not profile:
        messagebox.showwarning("Profile Not Found", f"Profile '{profile_name}' not found.")
        return

    housings_window = tk.Toplevel()
    housings_window.title(f"housings for Profile: {profile_name}")

    # Set housings_window to be on top of the root window
    housings_window.transient(root)
    housings_window.grab_set()  # Disable interaction with the main window
    housings_window.focus()  # Focus on the housings window

    housings_list = tk.Listbox(housings_window, width=50, height=20)
    housings_list.pack(side=tk.LEFT, fill=tk.Y)

    scrollbar = tk.Scrollbar(housings_window)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    housings_list.configure(yscrollcommand=scrollbar.set)
    scrollbar.configure(command=housings_list.yview)

    def print_housings():
        housings_list.delete(0, tk.END)
        for housings in profile.get('housings', []):
            housings_info = f"Name: {housings['name']}, Email: {housings.get('email', '')}, Phone: {housings.get('phone', '')}"
            housings_list.insert(tk.END, housings_info)

    def add_housings():
        def create_add_housings_window():
            add_housings_window = tk.Toplevel()
            add_housings_window.title("Add housings")
            add_housings_window.transient(housings_window)  # Make sure this window stays in front of the housings window
            add_housings_window.grab_set()  # Ensure the new window is active
            add_housings_window.focus()  # Focus on the add housings window

            tk.Label(add_housings_window, text="Name:").pack(pady=10)
            name_entry = tk.Entry(add_housings_window)
            name_entry.pack()

            tk.Label(add_housings_window, text="Email Address:").pack(pady=10)
            email_entry = tk.Entry(add_housings_window)
            email_entry.pack()

            tk.Label(add_housings_window, text="Phone Number:").pack(pady=10)
            phone_entry = tk.Entry(add_housings_window)
            phone_entry.pack()

            def save_housings():
                if 'housings' not in profile:
                    profile['housings'] = []
                new_housings = {
                    'name': name_entry.get(),
                    'phone': phone_entry.get(),
                    'email': email_entry.get()
                }
                profile['housings'].append(new_housings)
                save_to_json(profiles, PROFILES_FILE)
                print_housings()
                update_housings_label(profile)

                add_another = messagebox.askyesno("Add Another", "Would you like to add another housings?")
                if add_another:
                    name_entry.delete(0, tk.END)
                    phone_entry.delete(0, tk.END)
                    email_entry.delete(0, tk.END)
                    name_entry.focus_set()  # Refocus on the name entry for the next housings
                else:
                    add_housings_window.destroy()
                    housings_window.focus_set()  # Return focus to the housings window

            tk.Button(add_housings_window, text="Save housings", command=save_housings).pack(pady=10)

            name_entry.focus_set()  # Set focus to the name entry field

        create_add_housings_window()

    def edit_housings():
        selected_index = housings_list.curselection()
        if not selected_index:
            messagebox.showwarning("Selection Error", "No housings selected.")
            return

        selected_index = selected_index[0]
        selected_housings = profile['housings'][selected_index]

        def create_edit_housings_window():
            edit_housings_window = tk.Toplevel()
            edit_housings_window.title("Edit housings")
            edit_housings_window.transient(housings_window)  # Keep window in front
            edit_housings_window.grab_set()  # Make this window modal
            edit_housings_window.focus()  # Focus on the edit window

            tk.Label(edit_housings_window, text="Name:").pack(pady=10)
            name_entry = tk.Entry(edit_housings_window)
            name_entry.insert(0, selected_housings['name'])
            name_entry.pack()

            tk.Label(edit_housings_window, text="Email Address:").pack(pady=10)
            email_entry = tk.Entry(edit_housings_window)
            email_entry.insert(0, selected_housings.get('email', ''))
            email_entry.pack()

            tk.Label(edit_housings_window, text="Phone Number:").pack(pady=10)
            phone_entry = tk.Entry(edit_housings_window)
            phone_entry.insert(0, selected_housings.get('phone', ''))
            phone_entry.pack()

            def save_edits():
                profile['housings'][selected_index] = {
                    'name': name_entry.get(),
                    'email': email_entry.get(),
                    'phone': phone_entry.get()
                }
                save_to_json(profiles, PROFILES_FILE)
                messagebox.showinfo("Success", "housings updated successfully!")
                print_housings()  # Refresh the housings listbox
                edit_housings_window.destroy()

            tk.Button(edit_housings_window, text="Save Changes", command=save_edits).pack(pady=20)

        create_edit_housings_window()

    import tkinter.filedialog as filedialog

    def generate_pdf():
        # Open a file dialog to ask the user where to save the PDF
        pdf_filename = filedialog.asksaveasfilename(
            defaultextension=".pdf", 
            filetypes=[("PDF files", "*.pdf")],
            title="Save PDF As"
        )
        
        if not pdf_filename:  # If the user cancels, exit the function
            return
        
        c = canvas.Canvas(pdf_filename, pagesize=letter)
        width, height = letter

        c.drawString(100, height - 50, f"housings for Profile: {profile_name}")
        y_position = height - 100

        for housings in profile.get('housings', []):
            housings_info = f"Name: {housings['name']}, Email: {housings.get('email', '')}, Phone: {housings.get('phone', '')}"
            c.drawString(100, y_position, housings_info)
            y_position -= 20
            if y_position < 50:  # Create a new page if space runs out
                c.showPage()
                y_position = height - 50

        c.save()
        messagebox.showinfo("Success", f"PDF saved as {pdf_filename}")

    # Adding this to the housings window
    tk.Button(housings_window, text="Generate PDF", command=generate_pdf).pack(pady=5)


    tk.Button(housings_window, text="Add housings", command=add_housings).pack(pady=5)
    tk.Button(housings_window, text="Edit housings", command=edit_housings).pack(pady=5)

    print_housings()

    # Ensure the housings window stays in front of the profile manager window
    housings_window.protocol("WM_DELETE_WINDOW", lambda: (housings_window.grab_release(), housings_window.destroy()))



def open_contact2s2_window(profile_name):
    profile = next((p for p in profiles if p['name'] == profile_name), None)
    if not profile:
        messagebox.showwarning("Profile Not Found", f"Profile '{profile_name}' not found.")
        return

    contact2s2_window = tk.Toplevel()
    contact2s2_window.title(f"contact2s2 for Profile: {profile_name}")

    # Make the contact2s2 window modal and keep it focused
    contact2s2_window.grab_set()
    contact2s2_window.focus_set()

    contact2s2_list = tk.Listbox(contact2s2_window, width=50, height=20)
    contact2s2_list.pack(side=tk.LEFT, fill=tk.Y)

    scrollbar = tk.Scrollbar(contact2s2_window)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    contact2s2_list.configure(yscrollcommand=scrollbar.set)
    scrollbar.configure(command=contact2s2_list.yview)

    def print_contact2s2():
        contact2s2_list.delete(0, tk.END)
        for contact2 in profile.get('contact2s2', []):
            contact2_info = f"Name: {contact2['name']}, Phone: {contact2.get('phone', 'N/A')}, Email: {contact2.get('email', 'N/A')}"
            contact2s2_list.insert(tk.END, contact2_info)

    def add_contact2():
        add_contact2_window = tk.Toplevel()
        add_contact2_window.title("Add contact2")
        add_contact2_window.transient(contact2s2_window)  # Keep this window on top of the contact2s2 window

        tk.Label(add_contact2_window, text="Name:").pack(pady=10)
        name_entry = tk.Entry(add_contact2_window)
        name_entry.pack()
        name_entry.focus_set()  # Focus on the name entry field as soon as the window opens

        tk.Label(add_contact2_window, text="Phone:").pack(pady=10)
        phone_entry = tk.Entry(add_contact2_window)
        phone_entry.pack()

        tk.Label(add_contact2_window, text="Email:").pack(pady=10)
        email_entry = tk.Entry(add_contact2_window)
        email_entry.pack()

        def save_contact2():
            if 'contact2s2' not in profile:
                profile['contact2s2'] = []
            new_contact2 = {
                'name': name_entry.get(),
                'phone': phone_entry.get(),
                'email': email_entry.get()
            }
            profile['contact2s2'].append(new_contact2)
            save_to_json(profiles, PROFILES_FILE)
            print_contact2s2()
            update_contact2s2_label(profile)

            add_another = messagebox.askyesno("Add Another", "Would you like to add another contact2?")
            if add_another:
                name_entry.delete(0, tk.END)
                phone_entry.delete(0, tk.END)
                email_entry.delete(0, tk.END)
                name_entry.focus_set()  # Refocus on the name entry for the next contact2
            else:
                add_contact2_window.destroy()
                contact2s2_window.focus_set()  # Return focus to the contact2s2 window

        tk.Button(add_contact2_window, text="Save contact2", command=save_contact2).pack(pady=10)

        # Ensure the add contact2 window keeps focus and is modal relative to the contact2s2 window
        add_contact2_window.grab_set()
        add_contact2_window.focus_set()

    tk.Button(contact2s2_window, text="Add contact2", command=add_contact2).pack(pady=10)
    print_contact2s2()

def create_profile_window():
    create_window = tk.Toplevel()
    create_window.title("Create New Profile")

    tk.Label(create_window, text="Profile Name:").pack(pady=10)
    name_entry = tk.Entry(create_window)
    name_entry.pack()

    def save_profile():
        profile_name = name_entry.get()
        if not profile_name:
            messagebox.showwarning("Input Error", "Profile name cannot be empty.")
            return

        if any(p['name'] == profile_name for p in profiles):
            messagebox.showwarning("Profile Exists", f"Profile '{profile_name}' already exists.")
            return

        new_profile = {
            'name': profile_name,
            'vehicles': [],
            'contact2s2': [],
            'documents': [],
            'housings': None,  # Make housing initially None
            'banking': [],
            'credit_debts': []
        }
        profiles.append(new_profile)
        save_to_json(profiles, PROFILES_FILE)
        profiles_listbox.insert(tk.END, profile_name)
        create_window.destroy()

    tk.Button(create_window, text="Save Profile", command=save_profile).pack(pady=10)

    

# Function to delete a highlighted profile
def delete_profile():
    selected_index = profiles_listbox.curselection()
    if not selected_index:
        messagebox.showwarning("Selection Error", "No profile selected.")
        return

    selected_index = selected_index[0]
    selected_profile = profiles[selected_index]
    
    # Confirm profile deletion
    confirm = messagebox.askyesno("Delete Profile", f"Are you sure you want to delete '{selected_profile['name']}'?")
    if confirm:
        profiles.pop(selected_index)
        save_to_json(profiles, PROFILES_FILE)
        
        # Update the listbox
        profiles_listbox.delete(selected_index)

# Function to update labels based on the profile
def update_labels(profile):
    update_banking_label(profile)
    update_credit_label(profile)
    update_contacts_label(profile)
    update_contact2s2_label(profile)
    update_housings_label(profile)

def update_banking_label(profile):
    is_complete = profile and profile.get('banking')  # Checks if there's any banking info
    update_status_label(banking_info_label, bool(is_complete))

def update_credit_label(profile):
    is_complete = profile and profile.get('credit')  # Checks if there's any banking info
    update_status_label(credit_info_label, bool(is_complete))

def update_housings_label(profile):
    is_complete = profile and profile.get('housings')  # Checks if there's any banking info
    update_status_label(housing_info_label, bool(is_complete))

def update_contacts_label(profile):
    is_complete = profile and profile.get('contacts')  # Checks if there's any contacts
    update_status_label(contacts_label, bool(is_complete))

def update_contact2s2_label(profile):
    is_complete = profile and profile.get('contact2s2')  # Checks if there's any contacts
    update_status_label(contacts_label2, bool(is_complete))
# File to store contacts
CONTACTS_FILE = "contacts.json"

# Function to load contacts from file
def load_contacts():
    if os.path.exists(CONTACTS_FILE):
        with open(CONTACTS_FILE, 'r') as file:
            return json.load(file)
    return []

# Function to save contacts to file
def save_contacts(contacts):
    with open(CONTACTS_FILE, 'w') as file:
        json.dump(contacts, file)

# Function to open the manage contacts window
def open_contacts_window22(profile):
    contacts_window = tk.Toplevel()
    contacts_window.title("Manage Contacts")
    contacts_window.geometry("400x300")

    tk.Label(contacts_window, text="Contacts List:").pack(pady=10)

    # Create a listbox to display the contacts
    contacts_listbox = tk.Listbox(contacts_window, height=10, width=50)
    contacts_listbox.pack(pady=10)

    # Function to update the contacts listbox
    def print_contacts():
        contacts_listbox.delete(0, tk.END)  # Clear the listbox
        if 'contacts' in profile:
            for contact in profile['contacts']:
                # Check if 'related' key exists and handle missing cases
                related_status = "(Related)" if contact.get('related', "No") == "Yes" else "(Not Related)"
                contacts_listbox.insert(tk.END, f"{contact['name']} {related_status}")

    # Call this to populate the list when opening the window
    print_contacts()

    # Function to create the Add Contact window
    def add_contact():
        add_contact_window = tk.Toplevel(contacts_window)
        add_contact_window.title("Add Contact")

        tk.Label(add_contact_window, text="Name:").pack(pady=10)
        name_entry = tk.Entry(add_contact_window)
        name_entry.pack()

        tk.Label(add_contact_window, text="Email Address:").pack(pady=10)
        email_entry = tk.Entry(add_contact_window)
        email_entry.pack()

        tk.Label(add_contact_window, text="Phone Number:").pack(pady=10)
        phone_entry = tk.Entry(add_contact_window)
        phone_entry.pack()

        # Popup for the relation question
        def ask_relation():
            relation_popup = tk.Toplevel(add_contact_window)
            relation_popup.title("Relation Question")
            tk.Label(relation_popup, text="Is this person related to you?").pack(pady=10)

            is_related_var = tk.StringVar(value="No")

            def save_relation(answer):
                is_related_var.set(answer)
                relation_popup.destroy()

            tk.Button(relation_popup, text="Yes", command=lambda: save_relation("Yes")).pack(side=tk.LEFT, padx=10, pady=5)
            tk.Button(relation_popup, text="No", command=lambda: save_relation("No")).pack(side=tk.RIGHT, padx=10, pady=5)

            relation_popup.transient(add_contact_window)
            relation_popup.grab_set()
            relation_popup.focus()

            add_contact_window.wait_window(relation_popup)

            return is_related_var.get()

        # Function to save the contact
        def save_contact():
            if 'contacts' not in profile:
                profile['contacts'] = []  # Initialize 'contacts' list if it doesn't exist

            contact = {
                'name': name_entry.get(),
                'email': email_entry.get(),
                'phone': phone_entry.get(),
                'related': ask_relation()  # Store the answer from the popup
            }

            profile['contacts'].append(contact)  # Append the contact to the profile
            save_contacts(profile['contacts'])  # Save contacts to the file
            messagebox.showinfo("Success", "Contact added successfully!")
            print_contacts()  # Update the contacts listbox after adding a new contact
            add_contact_window.destroy()  # Close the add contact window

        tk.Button(add_contact_window, text="Save Contact", command=save_contact).pack(pady=20)

    # Button to add a new contact
    tk.Button(contacts_window, text="Add Contact", command=add_contact).pack(pady=10)

    contacts_window.grab_set()
    contacts_window.focus()

# Load contacts when the program starts
root = tk.Tk()
root.title("Profile Manager")

    # Create a canvas for scrolling
canvas = tk.Canvas(root, borderwidth=0)
canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

    # Create a scrollbar for the canvas
scrollbar = tk.Scrollbar(root, orient="vertical", command=canvas.yview)
scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Configure the canvas to work with the scrollbar
canvas.configure(yscrollcommand=scrollbar.set)

    # Create a frame inside the canvas to hold the main content
content_frame = tk.Frame(canvas)
canvas.create_window((0, 0), window=content_frame, anchor="nw")

    # Function to update the canvas scroll region
def update_scroll_region(event):
        canvas.configure(scrollregion=canvas.bbox("all"))

content_frame.bind("<Configure>", update_scroll_region)

# Define buttons and labels for each section
def create_button_with_label(frame, text, command):
    btn_frame = tk.Frame(frame)
    btn_frame.pack(fill=tk.X, pady=5)

    button = tk.Button(btn_frame, text=text, command=command)
    button.pack(side=tk.LEFT)

    label = tk.Label(btn_frame, text="Incomplete")
    label.pack(side=tk.LEFT, padx=10)

    return label



profiles_listbox = tk.Listbox(root)
profiles_listbox.pack(side=tk.LEFT, padx=20, pady=20)

# Frame to hold the buttons and labels
button_frame = tk.Frame(root)
button_frame.pack(side=tk.LEFT, padx=20, pady=20)

def create_button_with_label(frame, text, command):
    btn_frame = tk.Frame(frame)
    btn_frame.pack(fill=tk.X, pady=5)

    button = tk.Button(btn_frame, text=text, command=command)
    button.pack(side=tk.LEFT)

    label = tk.Label(btn_frame, text="Incomplete")
    label.pack(side=tk.LEFT, padx=10)

    return label

# Buttons and Labels for each section
tk.Button(root, text="Create Profile", command=lambda: create_profile_window()).pack(pady=5)
banking_info_label = create_button_with_label(button_frame, "Banking Info", lambda: open_banking_window(profiles_listbox.get(tk.ACTIVE)))
credit_info_label = create_button_with_label(button_frame, "cred Info", lambda: open_credit_window(profiles_listbox.get(tk.ACTIVE)))
contacts_label = create_button_with_label(button_frame, "Contacts", lambda: open_contacts_window(profiles_listbox.get(tk.ACTIVE)))
contacts_label2 = create_button_with_label(button_frame, "Contacts2", lambda: open_contact2s2_window(profiles_listbox.get(tk.ACTIVE)))
tk.Button(root, text="Delete pROFILE", command=delete_profile).pack(pady=10)
housing_info_label = create_button_with_label(button_frame, "housings", lambda: open_housings_window(profiles_listbox.get(tk.ACTIVE)))

def on_profile_select(event):
    selected_index = profiles_listbox.curselection()
    if selected_index:
        selected_profile = profiles[selected_index[0]]
        update_labels(selected_profile)

# Bind the selection event
profiles_listbox.bind("<<ListboxSelect>>", on_profile_select)
# Populate profiles listbox on startup
for profile in profiles:
    profiles_listbox.insert(tk.END, profile['name'])

# Start the main Tkinter event loop
root.mainloop()

