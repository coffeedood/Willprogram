from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
import tkinter as tk
from tkinter import messagebox
import json
import os
PROFILES_FILE = "profiles.json"

# Function to load profiles from JSON file
def load_profiles():
    if os.path.exists(PROFILES_FILE):
        with open(PROFILES_FILE, "r") as file:
            return json.load(file)
    return []

# Function to save profiles to JSON file
def save_profiles(profiles):
    with open(PROFILES_FILE, "w") as file:
        json.dump(profiles, file, indent=4)

# Load profiles initially
profiles = load_profiles()

# Function to save selected next steps to the profiles.json file
def save_selected_next_steps(selected_steps, profile_name):
    if selected_steps:
        profiles_data = load_profiles()
        profile = next((p for p in profiles_data if p['name'] == profile_name), None)
        if profile:
            profile["next_steps"] = selected_steps
            save_profiles(profiles_data)
            messagebox.showinfo("Steps Saved", f"Your selections have been saved for {profile_name}.")
        else:
            messagebox.showwarning("Profile Not Found", f"Profile '{profile_name}' does not exist.")
    else:
        messagebox.showwarning("Selection Error", "Please select at least one next step.")

# Function to open the Next Steps window
def save_selected_next_steps(selected_steps, profile_name):
    if selected_steps:
        # Load profiles data
        profiles_data = load_profiles()

        # Ensure profile exists
        profile = next((p for p in profiles_data if p['name'] == profile_name), None)
        if profile:
            # Save next steps under the profile
            profile["next_steps"] = selected_steps

            # Write back to the profiles file
            save_profiles(profiles_data)

            messagebox.showinfo("Steps Saved", f"Your selections have been saved for {profile_name}.")
        else:
            messagebox.showwarning("Profile Not Found", f"Profile '{profile_name}' does not exist.")
    else:
        messagebox.showwarning("Selection Error", "Please select at least one next step.")

# Open Next Steps window
def open_next_steps_window(profile_name):
    steps_window = tk.Toplevel()
    steps_window.title(f"Manage Next Steps for {profile_name}")

    tk.Label(steps_window, text="Next Steps (Yes or No):", font=("Arial", 14)).pack(pady=10)

    # List of next steps
    steps = [
        "Locate Will or Other Estate Planning Documents",
        "Will and Trust (See Section 17)",
        "Contact Organizations and Service Providers",
        "Insurance (See Section 18)",
        "Bank and Brokerage Accounts (See Section 19)",
        "Retirement Plans and Pensions (See Section 20)",
        "Government Benefits (See Section 21)",
        "Service Providers (See Section 10)",
        "Other: Add custom step 1",
        "Other: Add custom step 2",
        "Other: Add custom step 3",
        "Other: Add custom step 4"
    ]

    # Dictionary to store selected steps
    profiles_data = load_profiles()
    profile = next((p for p in profiles_data if p['name'] == profile_name), None)
    selected_steps = profile.get("next_steps", {}) if profile else {}

    # Create radio buttons for each step with "Yes" and "No" options
    step_vars = {}
    for step in steps:
        step_frame = tk.Frame(steps_window)
        step_frame.pack(anchor=tk.W, pady=5)

        # Step label
        tk.Label(step_frame, text=step, font=("Arial", 12)).pack(side=tk.LEFT)

        # Variables to store "Yes" or "No" selection
        step_vars[step] = tk.StringVar(value=selected_steps.get(step, ""))

        # Yes and No radio buttons
        yes_rb = tk.Radiobutton(step_frame, text="Yes", variable=step_vars[step], value="Yes")
        no_rb = tk.Radiobutton(step_frame, text="No", variable=step_vars[step], value="No")

        yes_rb.pack(side=tk.LEFT, padx=5)
        no_rb.pack(side=tk.LEFT, padx=5)

    # Save button
    def save_steps():
        # Collect selected steps
        final_selections = {step: var.get() for step, var in step_vars.items()}
        save_selected_next_steps(final_selections, profile_name)

    tk.Button(steps_window, text="Save", command=save_steps).pack(pady=10)

# Function to open the Vehicles window
def open_vehicles_window(profile_name, update_status_callback):
    vehicles_window = tk.Toplevel()
    vehicles_window.title(f"Manage vehicles for {profile_name}")

    tk.Label(vehicles_window, text="Vehicle Brand:").pack(pady=5)
    name_entry = tk.Entry(vehicles_window)
    name_entry.pack(pady=5)
    name_entry.focus_set()  # Set focus to the vehicle name entry field

    tk.Label(vehicles_window, text="Vehicle Model:").pack(pady=5)
    model_entry = tk.Entry(vehicles_window)
    model_entry.pack(pady=5)

    tk.Label(vehicles_window, text="Vehicle Color:").pack(pady=5)
    color_entry = tk.Entry(vehicles_window)
    color_entry.pack(pady=5)

    tk.Label(vehicles_window, text="Vehicle Address:").pack(pady=5)
    address_entry = tk.Entry(vehicles_window)
    address_entry.pack(pady=5)

    tk.Label(vehicles_window, text="Ownership Status:").pack(pady=5)
    relation_var = tk.StringVar(value="Friend")  # Default relation

    # Relation radio buttons
    relation_frame = tk.Frame(vehicles_window)
    relation_frame.pack(pady=5)
    tk.Radiobutton(relation_frame, text="Owner", variable=relation_var, value="Owner").pack(side=tk.LEFT, padx=5)
    tk.Radiobutton(relation_frame, text="This is a Rental Car", variable=relation_var, value="This is a Rental Car").pack(side=tk.LEFT, padx=5)
    tk.Radiobutton(relation_frame, text="Other", variable=relation_var, value="Other").pack(side=tk.LEFT, padx=5)

    # vehicles list display
    vehicles_listbox = tk.Listbox(vehicles_window, height=10, width=50)
    vehicles_listbox.pack(pady=10)

    def refresh_vehicles():
        vehicles_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for vehicle in profile_data.get('vehicles', []):
                vehicle_details = f"{vehicle['name']} | {vehicle['model']} | {vehicle['color']} | {vehicle['address']}| {vehicle['relation']}"
                vehicles_listbox.insert(tk.END, vehicle_details)

    def save_vehicle():
        vehicle_name = name_entry.get()
        model_number = model_entry.get()
        color_address = color_entry.get()
        address = address_entry.get()
        relation = relation_var.get()

        if vehicle_name and model_number and color_address and address and relation:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'vehicles' not in profile_data:
                    profile_data['vehicles'] = []
                profile_data['vehicles'].append({
                    "name": vehicle_name,
                    "model": model_number,
                    "color": color_address,
                    "address": address,
                    "relation": relation
                })
                # Clear the entry fields after saving
                name_entry.delete(0, tk.END)
                model_entry.delete(0, tk.END)
                color_entry.delete(0, tk.END)
                address_entry.delete(0, tk.END)
                
                update_status_callback()  # Update the vehicle status label
                refresh_vehicles()  # Refresh the vehicle list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill all fields.")

    tk.Button(vehicles_window, text="Save vehicle", command=save_vehicle).pack(pady=5)
    refresh_vehicles()  # Initial population of the vehicle list


import tkinter as tk
from tkinter import messagebox
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from tkinter import *

from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas as pdf_canvas
from tkinter import filedialog, messagebox
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas as pdf_canvas
from reportlab.lib.units import inch


def open_contacts_window(profile_name, update_status_callback):
    contacts_window = tk.Toplevel()
    contacts_window.title(f"Manage Contacts for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(contacts_window)
    scrollbar = tk.Scrollbar(contacts_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Existing fields for adding a contact
    tk.Label(scrollable_frame, text="Contact Name:").pack(pady=5)
    name_entry = tk.Entry(scrollable_frame)
    name_entry.pack(pady=5)
    name_entry.focus_set()

    tk.Label(scrollable_frame, text="Phone Number:").pack(pady=5)
    phone_entry = tk.Entry(scrollable_frame)
    phone_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Email Address:").pack(pady=5)
    email_entry = tk.Entry(scrollable_frame)
    email_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Address:").pack(pady=5)
    address_entry = tk.Entry(scrollable_frame)
    address_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Relation:").pack(pady=5)
    relation_var = tk.StringVar(value="Friend")

    # Relation radio buttons
    relation_frame = tk.Frame(scrollable_frame)
    relation_frame.pack(pady=5)
    tk.Radiobutton(relation_frame, text="Friend", variable=relation_var, value="Friend").pack(side=tk.LEFT, padx=5)
    tk.Radiobutton(relation_frame, text="Acquaintance", variable=relation_var, value="Acquaintance").pack(side=tk.LEFT, padx=5)
    tk.Radiobutton(relation_frame, text="Other", variable=relation_var, value="Other").pack(side=tk.LEFT, padx=5)

    # New fields for additional profile data
    additional_fields = [
        ("First Name", ""),
        ("Middle Name", ""),
        ("Last Name", ""),
        ("Maiden Name", ""),
        ("Date of Birth", ""),
        ("Birthplace", ""),
        ("Location of Birth Certificate", ""),
        ("Location of Adoption Documents", ""),
        ("Social Security Number", ""),
        ("Location of Social Security Card", ""),
        ("Driver’s License Number and State", "")
    ]
    
    entries = {}
    for field_name, _ in additional_fields:
        tk.Label(scrollable_frame, text=f"{field_name}:").pack(pady=5)
        entry = tk.Entry(scrollable_frame)
        entry.pack(pady=5)
        entries[field_name.lower().replace(" ", "_")] = entry

    # Contacts list display
    contacts_listbox = tk.Listbox(scrollable_frame, height=10, width=50)
    contacts_listbox.pack(pady=10)

    def refresh_contacts():
        contacts_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for contact in profile_data.get('contacts', []):
                contact_details = f"{contact['name']} | {contact['phone']} | {contact['email']} | {contact['address']} | {contact['relation']} | {contact['first_name']}"
                contacts_listbox.insert(tk.END, contact_details)

    def save_contact():
        # Gather data from entries
        contact_data = {
            "name": name_entry.get(),
            "phone": phone_entry.get(),
            "email": email_entry.get(),
            "address": address_entry.get(),
            "relation": relation_var.get()
        }
        for key, entry in entries.items():
            contact_data[key] = entry.get()

        # Check if all fields are filled
        if all(contact_data.values()):
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'contacts' not in profile_data:
                    profile_data['contacts'] = []
                profile_data['contacts'].append(contact_data)
                # Clear the entry fields after saving
                name_entry.delete(0, tk.END)
                phone_entry.delete(0, tk.END)
                email_entry.delete(0, tk.END)
                address_entry.delete(0, tk.END)
                for entry in entries.values():
                    entry.delete(0, tk.END)
                update_status_callback()
                refresh_contacts()
                save_profiles(profiles)
        else:
            messagebox.showwarning("Input Error", "Please fill all fields.")

    def open_contact_details(contact):
        contact_window = tk.Toplevel(contacts_window)
        contact_window.title(f"Details for {contact['name']}")

        details_entries = {}
        row = 0
        for key, value in contact.items():
            label = tk.Label(contact_window, text=key.replace('_', ' ').title())
            label.grid(row=row, column=0, padx=5, pady=5, sticky=tk.W)
            entry = tk.Entry(contact_window, width=40)
            entry.grid(row=row, column=1, padx=5, pady=5)
            entry.insert(0, value)
            details_entries[key] = entry
            row += 1

        def save_changes():
            for key, entry in details_entries.items():
                contact[key] = entry.get()
            messagebox.showinfo("Saved", "Changes have been saved.")
            contact_window.destroy()
            refresh_contacts()
            save_profiles(profiles)

        tk.Button(contact_window, text="Save Changes", command=save_changes).grid(row=row, columnspan=2, pady=10)

    def on_contact_double_click(event):
        selection = contacts_listbox.curselection()
        if selection:
            selected_index = selection[0]
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                contact = profile_data.get('contacts', [])[selected_index]
                open_contact_details(contact)


    def generate_pdf_of_contacts():
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if not profile_data or 'contacts' not in profile_data or not profile_data['contacts']:
            messagebox.showinfo("No Contacts", "No contacts to generate PDF.")
            return

        # Open a file dialog to select where to save the PDF
        file_name = filedialog.asksaveasfilename(
            defaultextension=".pdf",
            filetypes=[("PDF files", "*.pdf")],
            title="Save PDF as"
        )

        # If the user cancels the save dialog, return without doing anything
        if not file_name:
            return

        # Define margins and line height
        left_margin = inch
        right_margin = 7.5 * inch  # page width is 8.5 inches, so 7.5 gives a 1-inch margin on the right
        top_margin = 10 * inch - 0.5 * inch
        line_height = 14

        pdf = pdf_canvas.Canvas(file_name, pagesize=letter)
        pdf.setFont("Helvetica", 12)
        y_position = top_margin

        # Title of the PDF
        pdf.drawString(left_margin, y_position, f"Contacts for {profile_name}")
        y_position -= line_height * 2

        # Write each contact's details with word wrapping
        for contact in profile_data['contacts']:
            contact_details = (
                f"Name: {contact.get('name', '')}\n"
                f"Phone: {contact.get('phone', '')}\n"
                f"Email: {contact.get('email', '')}\n"
                f"Address: {contact.get('address', '')}\n"
                f"Relation: {contact.get('relation', '')}\n"
                f"First Name: {contact.get('first_name', '')}\n"
                f"Last Name: {contact.get('last_name', '')}\n"
            )

            # Wrap the text if it exceeds the right margin
            for line in contact_details.split("\n"):
                wrapped_text = pdf.beginText(left_margin, y_position)
                wrapped_text.setFont("Helvetica", 12)
                wrapped_text.setWordSpace(2)

                # Break lines that are too long to fit within the margins
                max_width = right_margin - left_margin
                while line:
                    text_width = pdf.stringWidth(line, "Helvetica", 12)
                    if text_width <= max_width:
                        wrapped_text.textLine(line)
                        line = ""
                    else:
                        # Find the maximum length that fits and split the line
                        for i in range(len(line), 0, -1):
                            if pdf.stringWidth(line[:i], "Helvetica", 12) <= max_width:
                                wrapped_text.textLine(line[:i])
                                line = line[i:].lstrip()
                                break
                pdf.drawText(wrapped_text)
                y_position -= line_height

                # If we reach the bottom of the page, create a new page
                if y_position < inch:
                    pdf.showPage()
                    pdf.setFont("Helvetica", 12)
                    y_position = top_margin

            # Add extra space between contacts
            y_position -= line_height

            # If we reach the bottom of the page, create a new page
            if y_position < inch:
                pdf.showPage()
                pdf.setFont("Helvetica", 12)
                y_position = top_margin

        pdf.save()
        messagebox.showinfo("PDF Generated", f"PDF saved as {file_name}")




    # Bind double-click event to listbox
    contacts_listbox.bind("<Double-1>", on_contact_double_click)

    # Save and PDF buttons
    tk.Button(scrollable_frame, text="Save Contact", command=save_contact).pack(pady=5)
    tk.Button(scrollable_frame, text="Generate PDF", command=generate_pdf_of_contacts).pack(pady=5)

    refresh_contacts()



def open_credit_window(profile_name, update_status_callback):
    credit_window = tk.Toplevel()
    credit_window.title(f"Manage credit for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(credit_window)
    scrollbar = tk.Scrollbar(credit_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Existing fields for adding a contact
    tk.Label(scrollable_frame, text="Contact Name:").pack(pady=5)
    name_entry = tk.Entry(scrollable_frame)
    name_entry.pack(pady=5)
    name_entry.focus_set()

    tk.Label(scrollable_frame, text="Phone Number:").pack(pady=5)
    phone_entry = tk.Entry(scrollable_frame)
    phone_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Email Address:").pack(pady=5)
    email_entry = tk.Entry(scrollable_frame)
    email_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Address:").pack(pady=5)
    address_entry = tk.Entry(scrollable_frame)
    address_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Relation:").pack(pady=5)
    relation_var = tk.StringVar(value="Friend")

    # Relation radio buttons
    relation_frame = tk.Frame(scrollable_frame)
    relation_frame.pack(pady=5)
    tk.Radiobutton(relation_frame, text="Friend", variable=relation_var, value="Friend").pack(side=tk.LEFT, padx=5)
    tk.Radiobutton(relation_frame, text="Acquaintance", variable=relation_var, value="Acquaintance").pack(side=tk.LEFT, padx=5)
    tk.Radiobutton(relation_frame, text="Other", variable=relation_var, value="Other").pack(side=tk.LEFT, padx=5)

    # New fields for additional profile data
    additional_fields = [
        ("First Name", ""),
        ("Middle Name", ""),
        ("Last Name", ""),
        ("Maiden Name", ""),
        ("Date of Birth", ""),
        ("Birthplace", ""),
        ("Location of Birth Certificate", ""),
        ("Location of Adoption Documents", ""),
        ("Social Security Number", ""),
        ("Location of Social Security Card", ""),
        ("Driver’s License Number and State", "")
    ]
    
    entries = {}
    for field_name, _ in additional_fields:
        tk.Label(scrollable_frame, text=f"{field_name}:").pack(pady=5)
        entry = tk.Entry(scrollable_frame)
        entry.pack(pady=5)
        entries[field_name.lower().replace(" ", "_")] = entry

    # credit list display
    credit_listbox = tk.Listbox(scrollable_frame, height=10, width=50)
    credit_listbox.pack(pady=10)

    def refresh_credit():
        credit_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for contact in profile_data.get('credit', []):
                contact_details = f"{contact['name']} | {contact['phone']} | {contact['email']} | {contact['address']} | {contact['relation']} | {contact['first_name']}"
                credit_listbox.insert(tk.END, contact_details)

    def save_contact():
        # Gather data from entries
        contact_data = {
            "name": name_entry.get(),
            "phone": phone_entry.get(),
            "email": email_entry.get(),
            "address": address_entry.get(),
            "relation": relation_var.get()
        }
        for key, entry in entries.items():
            contact_data[key] = entry.get()

        # Check if all fields are filled
        if all(contact_data.values()):
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'credit' not in profile_data:
                    profile_data['credit'] = []
                profile_data['credit'].append(contact_data)
                # Clear the entry fields after saving
                name_entry.delete(0, tk.END)
                phone_entry.delete(0, tk.END)
                email_entry.delete(0, tk.END)
                address_entry.delete(0, tk.END)
                for entry in entries.values():
                    entry.delete(0, tk.END)
                update_status_callback()
                refresh_credit()
                save_profiles(profiles)
        else:
            messagebox.showwarning("Input Error", "Please fill all fields.")

    def open_contact_details(contact):
        contact_window = tk.Toplevel(credit_window)
        contact_window.title(f"Details for {contact['name']}")

        details_entries = {}
        row = 0
        for key, value in contact.items():
            label = tk.Label(contact_window, text=key.replace('_', ' ').title())
            label.grid(row=row, column=0, padx=5, pady=5, sticky=tk.W)
            entry = tk.Entry(contact_window, width=40)
            entry.grid(row=row, column=1, padx=5, pady=5)
            entry.insert(0, value)
            details_entries[key] = entry
            row += 1

        def save_changes():
            for key, entry in details_entries.items():
                contact[key] = entry.get()
            messagebox.showinfo("Saved", "Changes have been saved.")
            contact_window.destroy()
            refresh_credit()
            save_profiles(profiles)

        tk.Button(contact_window, text="Save Changes", command=save_changes).grid(row=row, columnspan=2, pady=10)

    def on_contact_double_click(event):
        selection = credit_listbox.curselection()
        if selection:
            selected_index = selection[0]
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                contact = profile_data.get('credit', [])[selected_index]
                open_contact_details(contact)


    def generate_pdf_of_credit():
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if not profile_data or 'credit' not in profile_data or not profile_data['credit']:
            messagebox.showinfo("No credit", "No credit to generate PDF.")
            return

        # Open a file dialog to select where to save the PDF
        file_name = filedialog.asksaveasfilename(
            defaultextension=".pdf",
            filetypes=[("PDF files", "*.pdf")],
            title="Save PDF as"
        )

        # If the user cancels the save dialog, return without doing anything
        if not file_name:
            return

        # Define margins and line height
        left_margin = inch
        right_margin = 7.5 * inch  # page width is 8.5 inches, so 7.5 gives a 1-inch margin on the right
        top_margin = 10 * inch - 0.5 * inch
        line_height = 14

        pdf = pdf_canvas.Canvas(file_name, pagesize=letter)
        pdf.setFont("Helvetica", 12)
        y_position = top_margin

        # Title of the PDF
        pdf.drawString(left_margin, y_position, f"credit for {profile_name}")
        y_position -= line_height * 2

        # Write each contact's details with word wrapping
        for contact in profile_data['credit']:
            contact_details = (
                f"Name: {contact.get('name', '')}\n"
                f"Phone: {contact.get('phone', '')}\n"
                f"Email: {contact.get('email', '')}\n"
                f"Address: {contact.get('address', '')}\n"
                f"Relation: {contact.get('relation', '')}\n"
                f"First Name: {contact.get('first_name', '')}\n"
                f"Last Name: {contact.get('last_name', '')}\n"
            )

            # Wrap the text if it exceeds the right margin
            for line in contact_details.split("\n"):
                wrapped_text = pdf.beginText(left_margin, y_position)
                wrapped_text.setFont("Helvetica", 12)
                wrapped_text.setWordSpace(2)

                # Break lines that are too long to fit within the margins
                max_width = right_margin - left_margin
                while line:
                    text_width = pdf.stringWidth(line, "Helvetica", 12)
                    if text_width <= max_width:
                        wrapped_text.textLine(line)
                        line = ""
                    else:
                        # Find the maximum length that fits and split the line
                        for i in range(len(line), 0, -1):
                            if pdf.stringWidth(line[:i], "Helvetica", 12) <= max_width:
                                wrapped_text.textLine(line[:i])
                                line = line[i:].lstrip()
                                break
                pdf.drawText(wrapped_text)
                y_position -= line_height

                # If we reach the bottom of the page, create a new page
                if y_position < inch:
                    pdf.showPage()
                    pdf.setFont("Helvetica", 12)
                    y_position = top_margin

            # Add extra space between credit
            y_position -= line_height

            # If we reach the bottom of the page, create a new page
            if y_position < inch:
                pdf.showPage()
                pdf.setFont("Helvetica", 12)
                y_position = top_margin

        pdf.save()
        messagebox.showinfo("PDF Generated", f"PDF saved as {file_name}")




    # Bind double-click event to listbox
    credit_listbox.bind("<Double-1>", on_contact_double_click)

    # Save and PDF buttons
    tk.Button(scrollable_frame, text="Save Contact", command=save_contact).pack(pady=5)
    tk.Button(scrollable_frame, text="Generate PDF", command=generate_pdf_of_credit).pack(pady=5)

    refresh_credit()

def open_employment_window(profile_name, update_status_callback):
    employment_window = tk.Toplevel()
    employment_window.title(f"Manage Employment for {profile_name}")

    tk.Label(employment_window, text="Employer Name:").pack(pady=5)
    employer_entry = tk.Entry(employment_window)
    employer_entry.pack(pady=5)
    employer_entry.focus_set()

    tk.Label(employment_window, text="Position:").pack(pady=5)
    position_entry = tk.Entry(employment_window)
    position_entry.pack(pady=5)

    tk.Label(employment_window, text="Start Date (YYYY-MM-DD):").pack(pady=5)
    start_date_entry = tk.Entry(employment_window)
    start_date_entry.pack(pady=5)

    tk.Label(employment_window, text="End Date (YYYY-MM-DD):").pack(pady=5)
    end_date_entry = tk.Entry(employment_window)
    end_date_entry.pack(pady=5)

    tk.Label(employment_window, text="Address:").pack(pady=5)
    address_entry = tk.Entry(employment_window)
    address_entry.pack(pady=5)

    employment_listbox = tk.Listbox(employment_window, height=10, width=70)
    employment_listbox.pack(pady=10)

    def refresh_employment():
        employment_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for job in profile_data.get('employment', []):
                job_details = f"{job['employer']} | {job['position']} | {job['start_date']} - {job['end_date']} | {job['address']}"
                employment_listbox.insert(tk.END, job_details)

    def save_employment():
        employer = employer_entry.get()
        position = position_entry.get()
        start_date = start_date_entry.get()
        end_date = end_date_entry.get()
        address = address_entry.get()

        if employer and position and start_date and address:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'employment' not in profile_data:
                    profile_data['employment'] = []
                profile_data['employment'].append({
                    "employer": employer,
                    "position": position,
                    "start_date": start_date,
                    "end_date": end_date,
                    "address": address
                })
                employer_entry.delete(0, tk.END)
                position_entry.delete(0, tk.END)
                start_date_entry.delete(0, tk.END)
                end_date_entry.delete(0, tk.END)
                address_entry.delete(0, tk.END)

                update_status_callback()  # Update status for the employment section
                refresh_employment()  # Refresh the listbox
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill all required fields.")

    tk.Button(employment_window, text="Save Job", command=save_employment).pack(pady=5)
    refresh_employment()


import os
from tkinter import filedialog

# Function to generate a PDF for a given profile
def generate_profile_pdf(profile_name):
    profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
    if not profile_data:
        messagebox.showwarning("Profile Not Found", f"Profile '{profile_name}' does not exist.")
        return

    # Ask the user to select a folder to save the PDF
    folder_path = filedialog.askdirectory(title="Select Folder to Save PDF")
    if not folder_path:
        messagebox.showwarning("No Folder Selected", "Please select a folder to save the PDF.")
        return

    # Construct the full path for the PDF file
    pdf_filename = os.path.join(folder_path, f"{profile_name}_profile.pdf")
    c = canvas.Canvas(pdf_filename, pagesize=letter)
    width, height = letter

    # Set title and profile name at the top
    c.setFont("Helvetica-Bold", 16)
    c.drawString(100, height - 40, f"Profile: {profile_name}")
    c.setFont("Helvetica", 12)

    # Add Next Steps
    next_steps = profile_data.get('next_steps', {})
    c.drawString(100, height - 80, "Next Steps:")
    y_position = height - 100
    for step, response in next_steps.items():
        c.drawString(110, y_position, f"{step}: {response}")
        y_position -= 20

    # Add Contacts
    c.drawString(100, y_position - 20, "Contacts:")
    y_position -= 40
    for contact in profile_data.get('contacts', []):
        contact_info = f"Name: {contact['name']}, Phone: {contact['phone']}, Email: {contact['email']}, Address: {contact['address']}, Relation: {contact['relation']}"
        c.drawString(110, y_position, contact_info)
        y_position -= 20

    # Add Vehicles
    c.drawString(100, y_position - 20, "Vehicles:")
    y_position -= 40
    for vehicle in profile_data.get('vehicles', []):
        make = vehicle.get('name', 'N/A')
        model = vehicle.get('model', 'N/A')
        color = vehicle.get('color', 'N/A')
        year = vehicle.get('year', 'N/A')
        vehicle_info = f"Make: {make}, Model: {model}, Color: {color}, Year: {year}"
        c.drawString(110, y_position, vehicle_info)
        y_position -= 20

    # Save and close the PDF
    c.showPage()
    c.save()

    messagebox.showinfo("PDF Generated", f"PDF for {profile_name} has been generated and saved to '{pdf_filename}'.")

def open_biography_window(profile_name, update_status_callback):
    biography_window = tk.Toplevel()
    biography_window.title(f"Manage Biography for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(biography_window)
    scrollbar = tk.Scrollbar(biography_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering biography details
    tk.Label(scrollable_frame, text="Full Name:").pack(pady=5)
    name_entry = tk.Entry(scrollable_frame)
    name_entry.pack(pady=5)
    name_entry.focus_set()

    tk.Label(scrollable_frame, text="Date of Birth:").pack(pady=5)
    dob_entry = tk.Entry(scrollable_frame)
    dob_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Place of Birth:").pack(pady=5)
    place_of_birth_entry = tk.Entry(scrollable_frame)
    place_of_birth_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Occupation:").pack(pady=5)
    occupation_entry = tk.Entry(scrollable_frame)
    occupation_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Military Service:").pack(pady=5)
    military_service_var = tk.StringVar(value="No")  # Default is "No"

    # Military service radio buttons
    military_frame = tk.Frame(scrollable_frame)
    military_frame.pack(pady=5)
    tk.Radiobutton(military_frame, text="Yes", variable=military_service_var, value="Yes").pack(side=tk.LEFT, padx=5)
    tk.Radiobutton(military_frame, text="No", variable=military_service_var, value="No").pack(side=tk.LEFT, padx=5)

    tk.Label(scrollable_frame, text="Other Notable Information:").pack(pady=5)
    other_info_text = tk.Text(scrollable_frame, height=5, width=70)
    other_info_text.pack(pady=5)

    # Biography list display
    biography_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    biography_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_biography():
        biography_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for bio in profile_data.get('biographies', []):
                bio_details = (
                    f"{bio['name']} | {bio['dob']} | {bio['place_of_birth']} | "
                    f"{bio['occupation']} | Military: {bio['military_service']}"
                )
                biography_listbox.insert(tk.END, bio_details)

    # Save biography details
    def save_biography():
        name = name_entry.get()
        dob = dob_entry.get()
        place_of_birth = place_of_birth_entry.get()
        occupation = occupation_entry.get()
        military_service = military_service_var.get()
        other_info = other_info_text.get("1.0", tk.END).strip()

        if name and dob and place_of_birth and occupation:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'biographies' not in profile_data:
                    profile_data['biographies'] = []
                profile_data['biographies'].append({
                    "name": name,
                    "dob": dob,
                    "place_of_birth": place_of_birth,
                    "occupation": occupation,
                    "military_service": military_service,
                    "other_info": other_info
                })
                # Clear the entry fields after saving
                name_entry.delete(0, tk.END)
                dob_entry.delete(0, tk.END)
                place_of_birth_entry.delete(0, tk.END)
                occupation_entry.delete(0, tk.END)
                other_info_text.delete("1.0", tk.END)

                update_status_callback()  # Update the biography status label
                refresh_biography()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill all required fields.")

    # Add button to save biography
    tk.Button(scrollable_frame, text="Save Biography", command=save_biography).pack(pady=10)

    # Populate the listbox with existing biographies
    refresh_biography()



def open_pet_livestock_window(profile_name, update_status_callback):
    pet_livestock_window = tk.Toplevel()
    pet_livestock_window.title(f"Manage Pets and Livestock for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(pet_livestock_window)
    scrollbar = tk.Scrollbar(pet_livestock_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering pet/livestock details
    tk.Label(scrollable_frame, text="Animal Name:").pack(pady=5)
    name_entry = tk.Entry(scrollable_frame)
    name_entry.pack(pady=5)
    name_entry.focus_set()

    tk.Label(scrollable_frame, text="Type (e.g., Dog, Cow):").pack(pady=5)
    type_entry = tk.Entry(scrollable_frame)
    type_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Breed:").pack(pady=5)
    breed_entry = tk.Entry(scrollable_frame)
    breed_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Age:").pack(pady=5)
    age_entry = tk.Entry(scrollable_frame)
    age_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Location:").pack(pady=5)
    location_entry = tk.Entry(scrollable_frame)
    location_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Ownership Status:").pack(pady=5)
    ownership_var = tk.StringVar(value="Owned")  # Default ownership status

    # Ownership status radio buttons
    ownership_frame = tk.Frame(scrollable_frame)
    ownership_frame.pack(pady=5)
    tk.Radiobutton(ownership_frame, text="Owned", variable=ownership_var, value="Owned").pack(side=tk.LEFT, padx=5)
    tk.Radiobutton(ownership_frame, text="Fostered", variable=ownership_var, value="Fostered").pack(side=tk.LEFT, padx=5)
    tk.Radiobutton(ownership_frame, text="Other", variable=ownership_var, value="Other").pack(side=tk.LEFT, padx=5)

    # Pet/Livestock list display
    pet_livestock_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    pet_livestock_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_pet():
        pet_livestock_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for animal in profile_data.get('pet', []):
                animal_details = (
                    f"{animal['name']} | {animal['type']} | {animal['breed']} | "
                    f"{animal['age']} | {animal['location']} | {animal['ownership']}"
                )
                pet_livestock_listbox.insert(tk.END, animal_details)

    # Save pet/livestock details
    def save_pet_livestock():
        name = name_entry.get()
        animal_type = type_entry.get()
        breed = breed_entry.get()
        age = age_entry.get()
        location = location_entry.get()
        ownership = ownership_var.get()

        if name and animal_type and breed and age and location:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'pet' not in profile_data:
                    profile_data['pet'] = []
                profile_data['pet'].append({
                    "name": name,
                    "type": animal_type,
                    "breed": breed,
                    "age": age,
                    "location": location,
                    "ownership": ownership
                })
                # Clear the entry fields after saving
                name_entry.delete(0, tk.END)
                type_entry.delete(0, tk.END)
                breed_entry.delete(0, tk.END)
                age_entry.delete(0, tk.END)
                location_entry.delete(0, tk.END)

                update_status_callback()  # Update the pets and livestock status label
                refresh_pet()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill all required fields.")

    # Add button to save animal
    tk.Button(scrollable_frame, text="Save Animal", command=save_pet_livestock).pack(pady=10)

    # Populate the listbox with existing pets/livestock
    refresh_pet()


def open_children_window(profile_name, update_status_callback):
    children_window = tk.Toplevel()
    children_window.title(f"Manage Children for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(children_window)
    scrollbar = tk.Scrollbar(children_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering child details
    tk.Label(scrollable_frame, text="Child's Full Name:").pack(pady=5)
    name_entry = tk.Entry(scrollable_frame)
    name_entry.pack(pady=5)
    name_entry.focus_set()

    tk.Label(scrollable_frame, text="Date of Birth (YYYY-MM-DD):").pack(pady=5)
    dob_entry = tk.Entry(scrollable_frame)
    dob_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Birthplace:").pack(pady=5)
    birthplace_entry = tk.Entry(scrollable_frame)
    birthplace_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Relationship Type (e.g., Biological, Step, Adopted):").pack(pady=5)
    relationship_entry = tk.Entry(scrollable_frame)
    relationship_entry.pack(pady=5)

    tk.Label(scrollable_frame, text="Additional Notes:").pack(pady=5)
    notes_entry = tk.Entry(scrollable_frame)
    notes_entry.pack(pady=5)

    # Children list display
    children_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    children_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_children_list():
        children_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for child in profile_data.get('children', []):
                child_details = (
                    f"{child['name']} | {child['dob']} | {child['birthplace']} | "
                    f"{child['relationship']} | {child['notes']}"
                )
                children_listbox.insert(tk.END, child_details)

    # Save child details
    def save_child():
        name = name_entry.get()
        dob = dob_entry.get()
        birthplace = birthplace_entry.get()
        relationship = relationship_entry.get()
        notes = notes_entry.get()

        if name and dob and birthplace and relationship:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'children' not in profile_data:
                    profile_data['children'] = []
                profile_data['children'].append({
                    "name": name,
                    "dob": dob,
                    "birthplace": birthplace,
                    "relationship": relationship,
                    "notes": notes
                })
                # Clear the entry fields after saving
                name_entry.delete(0, tk.END)
                dob_entry.delete(0, tk.END)
                birthplace_entry.delete(0, tk.END)
                relationship_entry.delete(0, tk.END)
                notes_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_children_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill all required fields except Notes (optional).")

    # Add button to save child
    tk.Button(scrollable_frame, text="Save Child", command=save_child).pack(pady=10)

    # Populate the listbox with existing children
    refresh_children_list()


def open_letter_to_loved_ones(profile_name, update_status_callback):
    letter_window = tk.Toplevel()
    letter_window.title(f"Letter to Loved Ones for {profile_name}")

    # Create a canvas and scrollbar for the form
    canvas = tk.Canvas(letter_window)
    scrollbar = tk.Scrollbar(letter_window, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    # Pack the canvas and scrollbar
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Fields for entering recipient details
    tk.Label(scrollable_frame, text="Recipient's Name:").pack(pady=5)
    name_entry = tk.Entry(scrollable_frame)
    name_entry.pack(pady=5)
    name_entry.focus_set()

    tk.Label(scrollable_frame, text="Recipient's Address:").pack(pady=5)
    address_entry = tk.Entry(scrollable_frame)
    address_entry.pack(pady=5)

    # Recipients list display
    recipients_listbox = tk.Listbox(scrollable_frame, height=10, width=70)
    recipients_listbox.pack(pady=10)

    # Refresh listbox content
    def refresh_recipients_list():
        recipients_listbox.delete(0, tk.END)
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data:
            for recipient in profile_data.get('recipients', []):
                recipient_details = f"{recipient['name']} | {recipient['address']}"
                recipients_listbox.insert(tk.END, recipient_details)

    # Save recipient details
    def save_recipient():
        name = name_entry.get()
        address = address_entry.get()

        if name and address:
            profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
            if profile_data:
                if 'recipients' not in profile_data:
                    profile_data['recipients'] = []
                profile_data['recipients'].append({"name": name, "address": address})
                # Clear the entry fields after saving
                name_entry.delete(0, tk.END)
                address_entry.delete(0, tk.END)

                update_status_callback()  # Update the status label for this section
                refresh_recipients_list()  # Refresh the list display
                save_profiles(profiles)  # Save profiles to file
        else:
            messagebox.showwarning("Input Error", "Please fill out both fields.")

    # Add button to save recipient
    tk.Button(scrollable_frame, text="Add Recipient", command=save_recipient).pack(pady=10)

    # Button to proceed to letter writing
    def open_letter_writing_window():
        # Close the current window
        letter_window.destroy()

        # Open the letter writing window
        letter_writing_window = tk.Toplevel()
        letter_writing_window.title(f"Write Letter for {profile_name}")

        tk.Label(letter_writing_window, text="Write Your Letter Below:").pack(pady=10)

        # Textbox for writing the letter
        letter_textbox = tk.Text(letter_writing_window, height=20, width=70)
        letter_textbox.pack(pady=10)

        # Populate the letter content if it exists
        profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)
        if profile_data and 'letter_content' in profile_data:
            letter_textbox.insert("1.0", profile_data['letter_content'])

        # Save the letter content
        def save_letter():
            letter_content = letter_textbox.get("1.0", tk.END).strip()
            if profile_data:
                profile_data['letter_content'] = letter_content
                save_profiles(profiles)  # Save profiles to file
                update_status_callback()  # Update the status label for this section
                messagebox.showinfo("Success", "Letter content saved successfully!")
                letter_writing_window.destroy()

        tk.Button(letter_writing_window, text="Save Letter", command=save_letter).pack(pady=10)

    tk.Button(scrollable_frame, text="Write Letter to Loved Ones", command=open_letter_writing_window).pack(pady=10)

    # Populate the listbox with existing recipients
    refresh_recipients_list()




def open_profile_window(profile_name):
    profile_window = tk.Toplevel()
    profile_window.title(f"Profile: {profile_name}")
    profile_window.state('zoomed')

    tk.Label(profile_window, text=f"Manage {profile_name}'s Information", font=("Arial", 20)).grid(row=0, column=0, columnspan=2, pady=10)
    profile_data = next((profile for profile in profiles if profile['name'] == profile_name), None)

    if profile_data:
        # Manage Next Steps button
        tk.Button(profile_window, text="Manage Next Steps", command=lambda: open_next_steps_window(profile_name)).grid(row=1, column=0, pady=5, padx=10)

        # Function to update the status labels
        def update_status_callback():
            contact_status = "Complete" if profile_data.get('contacts', []) else "Incomplete"
            contact_status_label.config(text=contact_status)
            vehicle_status = "Complete" if profile_data.get('vehicles', []) else "Incomplete"
            vehicle_status_label.config(text=vehicle_status)
            credit_status = "Complete" if profile_data.get('credit', []) else "Incomplete"
            credit_status_label.config(text=credit_status)
            pet_status = "Complete" if profile_data.get('pet', []) else "Incomplete"
            pet_status_label.config(text=pet_status)
            children_status = "Complete" if profile_data.get('children', []) else "Incomplete"
            children_status_label.config(text=children_status)
            children_status = "Complete" if profile_data.get('children', []) else "Incomplete"
            children_status_label.config(text=children_status)
            biography_status = "Complete" if profile_data.get('biographies', []) else "Incomplete"
            biography_status_label.config(text=biography_status)


        # Contacts section
        contact_status = "Complete" if profile_data.get('contacts', []) else "Incomplete"
        tk.Button(profile_window, text="Manage Contacts", command=lambda: open_contacts_window(profile_name, update_status_callback)).grid(row=2, column=0, pady=5, padx=10)
        contact_status_label = tk.Label(profile_window, text=contact_status)
        contact_status_label.grid(row=2, column=1)

        # Vehicles section
        vehicle_status = "Complete" if profile_data.get('vehicles', []) else "Incomplete"
        tk.Button(profile_window, text="Manage Vehicles", command=lambda: open_vehicles_window(profile_name, update_status_callback)).grid(row=3, column=0, pady=5, padx=10)
        vehicle_status_label = tk.Label(profile_window, text=vehicle_status)
        vehicle_status_label.grid(row=3, column=1)
        tk.Button(profile_window, text="Generate PDF", command=lambda: generate_profile_pdf(profile_name)).grid(row=5, column=0, pady=5, padx=10)
        credit_status = "Complete" if profile_data.get('credit', []) else "Incomplete"
        tk.Button(profile_window, text="Manage creadity", command=lambda: open_credit_window(profile_name, update_status_callback)).grid(row=6, column=0, pady=5, padx=10)
        credit_status_label = tk.Label(profile_window, text=credit_status)
        credit_status_label.grid(row=6, column=1)
        pet_status = "Complete" if profile_data.get('pet', []) else "Incomplete"
        tk.Button(profile_window, text="Manage pets", command=lambda: open_pet_livestock_window(profile_name, update_status_callback)).grid(row=8, column=0, pady=5, padx=10)
        pet_status_label = tk.Label(profile_window, text=pet_status)
        pet_status_label.grid(row=8, column=1)
        pet_status = "Complete" if profile_data.get('pet', []) else "Incomplete"
        tk.Button(profile_window, text="Manage letter to loved ones", command=lambda: open_letter_to_loved_ones(profile_name, update_status_callback)).grid(row=10, column=0, pady=5, padx=10)
        pet_status_label = tk.Label(profile_window, text=pet_status)
        pet_status_label.grid(row=8, column=1)

        children_status = "Complete" if profile_data.get('children', []) else "Incomplete"
        tk.Button(profile_window, text="Manage chidlren", command=lambda: open_children_window(profile_name, update_status_callback)).grid(row=9, column=0, pady=5, padx=10)
        children_status_label = tk.Label(profile_window, text=children_status)
        children_status_label.grid(row=9, column=1)

        biography_status = "Complete" if profile_data.get('biographies', []) else "Incomplete"
        tk.Button(profile_window, text="Manage biographys", command=lambda: open_biography_window(profile_name, update_status_callback)).grid(row=3, column=0, pady=5, padx=10)
        biography_status_label = tk.Label(profile_window, text=biography_status)
        biography_status_label.grid(row=12, column=1)

    # Exit button to close the profile window
    tk.Button(profile_window, text="Exit", command=profile_window.destroy).grid(row=7, column=0, pady=5, padx=10)

# Function to handle double-click on a profile in the listbox
def on_profile_double_click(event):
    selected_index = profiles_listbox.curselection()
    if selected_index:
        selected_profile_name = profiles_listbox.get(selected_index[0])
        open_profile_window(selected_profile_name)

# Main window setup
root = tk.Tk()
root.title("Profiles Management")

tk.Label(root, text="Profiles", font=("Arial", 30)).pack(pady=10)

profiles_listbox = tk.Listbox(root, height=10, width=50)
profiles_listbox.pack(pady=10)
for profile in profiles:
    profiles_listbox.insert(tk.END, profile['name'])

profiles_listbox.bind("<Double-Button-1>", on_profile_double_click)

# Add new profile button
def add_new_profile():
    new_profile_name = new_profile_entry.get().strip()
    if new_profile_name:
        if any(p['name'] == new_profile_name for p in profiles):
            messagebox.showwarning("Duplicate Profile", "A profile with this name already exists.")
        else:
            profiles.append({'name': new_profile_name})
            save_profiles(profiles)
            profiles_listbox.insert(tk.END, new_profile_name)
            new_profile_entry.delete(0, tk.END)
            messagebox.showinfo("Profile Added", f"Profile '{new_profile_name}' has been added.")
    else:
        messagebox.showwarning("Input Error", "Please enter a profile name.")

# Entry and button to add new profiles
new_profile_entry = tk.Entry(root)
new_profile_entry.pack(pady=5)
tk.Button(root, text="Add New Profile", command=add_new_profile).pack(pady=5)

# Start the main loop
root.mainloop()
